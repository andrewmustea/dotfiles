#
# ~/.bashrc
#


# If not running interactively, don't do anything
case $- in
    *i*) ;;
    *) return ;;
esac


# --------------------------------------------------
# shell options
# --------------------------------------------------


# shopt
#
shopt -s \
    autocd cdspell checkhash checkjobs checkwinsize cmdhist dirspell dotglob \
    expand_aliases extglob extquote globstar histappend interactive_comments \
    no_empty_cmd_completion progcomp promptvars sourcepath xpg_echo
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        source /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        source /etc/bash_completion
    fi
fi


# sudo
#
alias sudo='sudo -v; sudo --preserve-env '


# command-not-found
#
if [ -x /usr/lib/command-not-found ] \
    || [ -x /usr/share/command-not-found/command-not-found ]; then
    command_not_found_handle() {
        # check because c-n-f could've been removed in the meantime
        if [ -x /usr/lib/command-not-found ]; then
            /usr/lib/command-not-found -- "$1"
            return $?
        elif [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1"
            return $?
        else
            printf "%s: command not found\n" "$1" >&2
            return 127
        fi
    }
fi


# XDG defaults
#
export DATA="$HOME/.local/share"
export CONFIG="$HOME/.config"
export STATE="$HOME/.local/state"
export CACHE="$HOME/.cache"
export XDG_DATA_HOME=$DATA
export XDG_CONFIG_HOME=$CONFIG
export XDG_STATE_HOME=$STATE
export XDG_CACHE_HOME=$CACHE

if pidof "systemd" &>/dev/null; then
    RUNTIME="/run/user/$UID"
else
    mkdir --parents /tmp/user/${UID}
    RUNTIME="/tmp/user/$UID"
fi
export XDG_RUNTIME_DIR=$RUNTIME


# bash history
#
PROMPT_COMMAND='history -a'
HISTSIZE=10000
HISTFILESIZE=100000
export HISTCONTROL=ignoredups
export HISTIGNORE='history:pwd:ls:ll:la:l:'
export HISTTIMEFORMAT='%F %T '
export HISTFILE="${STATE}"/bash/history


# distro settings
#
DISTRO="$(grep "^ID=" /etc/os-release | awk -F "=" '{ print $2 }')"
unset ARCH UBUNTU

if [[ "$DISTRO" == "arch" ]]; then
    export ARCH=1
    PACKAGE_MANAGER=pacman
    if which paru &>/dev/null; then
        export PACKAGE_MANAGER=paru
    elif which yay &>/dev/null; then
        export PACKAGE_MANAGER=yay
    else
        echo "No AUR helper detected. Using pacman as the package manager."
    fi

    alias pac='"$PACKAGE_MANAGER"'
    alias pacsearch='$PACKAGE_MANAGER -Ss'
    alias pacquery='$PACKAGE_MANAGER -Q'
elif [[ "$DISTRO" == "ubuntu" ]]; then
    UBUNTU=1
    which nala &>/dev/null && alias apt='nala'
else
    echo "Unknown Linux Distro: $DISTRO"
fi


# --------------------------------------------------
# extra XDG settings
# --------------------------------------------------


# xauth
#
export XAUTHORITY="$RUNTIME"/Xauthority


# wget
#
alias wget="wget --hsts-file=\"$DATA/wget-hsts\""


# azure
#
export AZURE_CONFIG_DIR="$DATA"/azure
export AZURE_DEVOPS_CACHE_DIR="$CACHE"/azure-devops


# npm
#
export NPM_CONFIG_USERCONFIG="$CONFIG"/npm/npmrc


# gem
#
export GEM_SPEC_CACHE="${XDG_CACHE_HOME}"/gem


# --------------------------------------------------
# interactive bash settings
# --------------------------------------------------


# ls
#
alias ls='ls -hF --color=auto'
alias ll='ls -l'
alias la='ls -Al'
alias l='ls -C'


# mkdir
#
alias mkdir='mkdir --parents'


# colors
#
alias dir='dir --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias dmesg='dmesg --color'

GCC_COLORS="$(printf "error=01;31:warning=01;35:note=01;%s" \
    "36:caret=01;32:locus=01:quote=01")"
export GCC_COLORS


# gpg and pass
#
GPG_TTY=$(tty)
export GPG_TTY
export GNUPGHOME="$DATA"/gnupg
export PASSWORD_STORE_DIR="$DATA"/pass


# diff
#
alias diffdir='diff -qr'


# nvim
#
export EDITOR='nvim'
which vim &>/dev/null && alias vim='nvim'
alias {vi,nvi}='nvim'
alias {vd,nvd,nvimdiff}='nvim -d'
alias nvim-remove-swap='rm -rf "$XDG_DATA_HOME/nvim/swap/"'


# less
#
LESS_TERMCAP_mb="$(printf '\E[01;31m')"
LESS_TERMCAP_md="$(printf '\E[01;38;5;74m')"
LESS_TERMCAP_me="$(printf '\E[0m')"
LESS_TERMCAP_se="$(printf '\E[0m')"
LESS_TERMCAP_so="$(printf '\E[38;5;246m')"
LESS_TERMCAP_ue="$(printf '\E[0m')"
LESS_TERMCAP_us="$(printf '\E[04;38;5;146m')"

export LESS_TERMCAP_mb
export LESS_TERMCAP_md
export LESS_TERMCAP_me
export LESS_TERMCAP_se
export LESS_TERMCAP_so
export LESS_TERMCAP_ue
export LESS_TERMCAP_us

export LESSHISTFILE="$CACHE"/less/history
alias less='less -QR'
alias man='man -P "less -QR"'

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"


# wsl settings
#
if [[ -n "$WSLENV" ]]; then
    winver="$(powershell.exe \[System.Environment\]::OSVersion.Version.Major)"

    if [[ "${winver%$'\r'}" == 10 ]]; then
        winpath="$(powershell.exe -command "echo \"\${env:USERPROFILE}\"")"
        xauthfile="$(wslpath "$winpath" | sed 's/[\r]//g')/.Xauthority"
        if [[ -f "$xauthfile" ]]; then
            touch "$XAUTHORITY"
            xauth -q merge "$xauthfile"
            DISPLAY="$(ip route show default | cut -d ' ' -f 3):0"
            LIBGL_ALWAYS_INDIRECT=0
            GALLIUM_DRIVER=llvmpipe
            export DISPLAY
            export LIBGL_ALWAYS_INDIRECT
            export GALLIUM_DRIVER
        fi
    fi

    # windows paths
    winpath="$(powershell.exe -command "echo \"\${env:USERPROFILE}\"")"

    WIN_USER="$(wslpath "$winpath")"
    export WIN_USER
    export WIN_DOC="$WIN_USER/Documents"
    export WIN_DOWN="$WIN_USER/Downloads"

    alias win_user='cd "$WIN_USER"'
    alias win_doc='cd "$WIN_DOC"'
    alias win_down='cd "$WIN_DOWN"'

    print-path() {
        printf "%s\n" "${PATH//:/$'\n'}" | grep -v '^/mnt/c/'
    }
else
    print-path() {
        printf "%s\n" "${PATH//:/$'\n'}"
    }
fi


# --------------------------------------------------
# binaries
# --------------------------------------------------


# local home bin
#
HOME_BIN="$HOME/.local/bin"
if [[ "$PATH" != *$HOME_BIN* ]]; then
    export PATH="${PATH:+${PATH}:}$HOME_BIN"
fi


# python
#
alias {pip,pip3}='python3 -m pip'

pip-update-all() {
    sudo -H pip list --outdated --format=freeze | grep -v '^\-e' | \
        cut -d = -f 1 | xargs -n1 sudo -H pip install -U
}


# rust
#
export CARGO_HOME="$DATA"/cargo
export RUSTUP_HOME="$DATA"/rustup
if [[ -n "$UBUNTU" ]] && [[ -d "$CARGO_HOME/bin" ]] && \
    [[ "$PATH" != *$CARGO_HOME/bin* ]]; then
    export PATH="$CARGO_HOME/bin:$PATH"

    # bat cache
    if ! [[ -d "$CACHE/bat" ]]; then
        echo "Rebuilding bat cache..."
        bat cache --build
    fi
fi


# go
#
if [[ -n "$UBUNTU" ]]; then
    GO_BIN=/usr/local/go/bin
    if [[ -d "$GO_BIN" ]]; then
        if [[ "$PATH" != *$GO_BIN* ]]; then
            export PATH="${PATH:+${PATH}:}$GO_BIN"
        fi
        export GOPATH="$DATA"/go
        if [[ -d "$GOPATH"/bin ]] && [[ "$PATH" != *$GOPATH/bin* ]]; then
            export PATH="${PATH:+${PATH}:}$GOPATH/bin"
        fi
    fi
fi


# haskell
#
if [[ -n "$UBUNTU" ]]; then
    export CABAL_DIR="$DATA"/cabal
    if [[ -d "$CABAL_DIR" ]] && [[ "$PATH" != *$CABAL_DIR/bin* ]]; then
        export PATH="$CABAL_DIR/bin:$PATH"
    fi
fi


# fzf
#
FZF_DIR="$DATA/fzf"
FZF_ENV="$CONFIG/fzf/fzf.bash"
[[ -f "$FZF_ENV" ]] && [[ -x "$FZF_DIR/bin/fzf" ]] && source "$FZF_ENV"

update-fzf() {
    if ! [[ -d $FZF_DIR ]]; then
        echo "Couldn't find fzf direcotry in '$FZF_DIR'"
        exit 1
    fi
    git -C "$FZF_DIR" pull
    "$FZF_DIR/install --xdg --bin"
}

# fzf uses fd-find
if which fd &>/dev/null; then
    export FZF_DEFAULT_COMMAND='command fd -HI --type file'
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
fi


# lua lsp
#
LUA_LSP="$DATA/lua-language-server/bin"
if [[ -d "$LUA_LSP" ]] && [[ "$PATH" != *$LUA_LSP* ]]; then
    export PATH="${PATH:+${PATH}:}$LUA_LSP"
fi


# --------------------------------------------------
# projects
# --------------------------------------------------


# local projects
#
PROJECTS_DIR="$HOME/projects"
export PROJECTS_DIR

ASCII_ART="$PROJECTS_DIR/ascii_art"
[[ -d "$ASCII_ART" ]] && source "$ASCII_ART/ascii.bash"


# --------------------------------------------------
# git settings
# --------------------------------------------------


# git aliases
#
alias gs='git status'
alias gf='git fetch'
alias gfa='git fetch --all'
alias gp='git pull'
alias gst='git stash'
alias ga='git add'
alias gaa='git add .'
alias gc='git commit'
alias gca='git commit --amend'
alias gb='git branch'
alias gd='git diff'
alias gdh='git diff HEAD'
alias gds='git diff --staged'
alias gdt='git difftool'
alias gdth='git difftool HEAD'
alias gdts='git difftool --staged'
alias gmt='git mergetool'
alias git-last-message='git show -s --format=%s'
alias git-reset-last='git reset HEAD~1'
alias rebase-origin='rebase-remote origin'
alias rebase-upstream='rebase-remote upstream'


# print the branch name of the current directory or a given one
get-branch-name() {
    local dir=$PWD
    if [[ -n "$1" ]]; then
        dir="$1"
    fi

    git -C "$dir" rev-parse --abbrev-ref HEAD
}

# run an interactive rebase starting at a given commit
rebase-commit() {
    if [[ -z "$1" ]]; then
        echo "error: missing commit-id"
        echo "usage: update-past-commit <commit-id>"
        return 1
    fi

    git rebase --interactive "$1"^
}

# rebase a branch on a given remote without having to manually stash any changes
rebase-remote() {
    if [[ $# -eq 0 ]]; then
        echo 'error: need remote name'
        echo 'usage: rebase-remote <remote> [branch]'
    fi

    local current_branch
    current_branch=$(get-branch-name "$2")
    if [[ -z "$current_branch" ]]; then
        return 1
    fi

    local branch="master"
    if [[ $# -gt 1 ]]; then
        branch="$2"
    fi

    git fetch --all
    git rebase "$1/$branch" "$branch"

    if [[ "$current_branch" != "$branch" ]]; then
        git checkout "$current_branch"
    fi
}

# add a line to a repositories .git/info/exclude
add-exclude() {
    local repo_config="$PWD"
    if [[ $# -eq 2 ]]; then
        repo_config=$2
    elif [[ $# -ne 1 ]]; then
        echo "error: bad arguments: '$*'"
        echo 'usage: add_exclude <exclude-line> [repo-directory]'
        return 1
    fi

    repo_config+='/.git/info/exclude'
    if [[ -z "$repo_config" ]]; then
        echo "error: repo_config not found: '$repo_config'"
        return 1
    fi

    if ! grep -q "^${1}\$" "$repo_config"; then
        echo "adding '$1' to '$repo_config'"
        echo "$1" >> "$repo_config"
    else
        echo "'$1' already exists in '$repo_config'"
    fi
}

# add the hidden .vscode directory to .git/info/exclude
add-exclude-vscode() {
    local repo=$PWD
    if [[ -n "$1" ]]; then
        repo=$1
    fi
    add-exclude '.vscode/' "$repo"
}


# --------------------------------------------------
# other
# --------------------------------------------------


# ips and ssh targets
#
alias pingpath='mtr'
alias myip='curl -s checkip.amazonaws.com'


# permissions
#
alias mx='chmod a+x'


# other functions
#
psgrep() {
    pgrep "$@" | xargs --no-run-if-empty ps -fp
}

pskill() {
    local pid
    pid=$(pgrep "$@" | xargs -r ps --no-headers -fp | awk '{ print $2 }')
    echo "killing $1 (process $pid)..."
    kill -9 "$pid"
}

extract() {
    if [ -f "$1" ]; then
        case $1 in
            *.tar.bz2) tar xvjf "$1" ;;
            *.tar.gz) tar xvzf "$1" ;;
            *.tar.xz) tar xvf "$1" ;;
            *.bz2) bunzip2 "$1" ;;
            *.rar) unrar x "$1" ;;
            *.gz) gunzip "$1" ;;
            *.tar) tar xvf "$1" ;;
            *.tbz2) tar xvjf "$1" ;;
            *.tgz) tar xvzf "$1" ;;
            *.zip) unzip "$1" ;;
            *.Z) uncompress "$1" ;;
            *.7z) 7z x "$1" ;;
            *) echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

