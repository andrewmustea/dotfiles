#
# ~/.bashrc
#


# If not running interactively, don't do anything
case $- in
    *i*) ;;
    *) return ;;
esac


# shell options
#
shopt -s checkwinsize
shopt -s histappend
shopt -s extglob
shopt -s expand_aliases
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        source /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        source /etc/bash_completion
    fi
fi

if [ -x /usr/lib/command-not-found ] \
    || [ -x /usr/share/command-not-found/command-not-found ]; then
    command_not_found_handle() {
        # check because c-n-f could've been removed in the meantime
        if [ -x /usr/lib/command-not-found ]; then
            /usr/lib/command-not-found -- "$1"
            return $?
        elif [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1"
            return $?
        else
            printf "%s: command not found\n" "$1" >&2
            return 127
        fi
    }
fi


# XDG
#
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_STATE_HOME="$HOME/.local/state"
export XDG_CACHE_HOME="$HOME/.cache"

if pidof "systemd" &>/dev/null; then
    export XDG_RUNTIME_DIR="/run/user/$UID"
else
    mkdir --parents /tmp/user/${UID}
    export XDG_RUNTIME_DIR="/tmp/user/$UID"
fi


# history
#
PROMPT_COMMAND='history -a'
HISTSIZE=10000
HISTFILESIZE=10000
export HISTCONTROL=ignoredups
export HISTIGNORE='history:pwd:ls:ll:la:l:'
export HISTFILE="${XDG_STATE_HOME}"/bash/history


# sudo
#
# refresh sudo and export environment
alias sudo='sudo -v; sudo --preserve-env '


# xauth
#
export XAUTHORITY="$XDG_RUNTIME_DIR"/Xauthority


# ls
#
alias ls='ls -hF --color=auto'
alias ll='ls -l'
alias la='ls -Al'
alias l='ls -C'


# mkdir
#
alias mkdir='mkdir --parents'


# colors
#
alias dir='dir --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias dmesg='dmesg --color'

GCC_COLORS="$(printf "error=01;31:warning=01;35:note=01;%s" \
    "36:caret=01;32:locus=01:quote=01")"
export GCC_COLORS


# gpg and pass
#
GPG_TTY=$(tty)
export GPG_TTY
export GNUPGHOME="$XDG_DATA_HOME"/gnupg
export PASSWORD_STORE_DIR="$XDG_DATA_HOME"/pass


# wget
#
alias wget=wget --hsts-file="$XDG_DATA_HOME/wget-hsts"


# nvim
#
export EDITOR='nvim'
which vim &>/dev/null && alias vim='nvim'
alias {vi,nvi}='nvim'
alias {vd,nvd,nvimdiff}='nvim -d'
alias nvim-remove-swap='rm -rf ~/.local/share/nvim/swap/'


# less
#
LESS_TERMCAP_mb="$(printf '\E[01;31m')"
LESS_TERMCAP_md="$(printf '\E[01;38;5;74m')"
LESS_TERMCAP_me="$(printf '\E[0m')"
LESS_TERMCAP_se="$(printf '\E[0m')"
LESS_TERMCAP_so="$(printf '\E[38;5;246m')"
LESS_TERMCAP_ue="$(printf '\E[0m')"
LESS_TERMCAP_us="$(printf '\E[04;38;5;146m')"

export LESS_TERMCAP_mb
export LESS_TERMCAP_md
export LESS_TERMCAP_me
export LESS_TERMCAP_se
export LESS_TERMCAP_so
export LESS_TERMCAP_ue
export LESS_TERMCAP_us

export LESSHISTFILE="$XDG_CACHE_HOME"/less/history
alias less='less -QR'
alias man='man -P "less -QR"'

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"


# diff
#
alias diffdir='diff -qr'


# python
#
alias {pip,pip3}='python3 -m pip'
pip-update-all() {
    sudo -H pip list --outdated --format=freeze | grep -v '^\-e' | \
        cut -d = -f 1 | xargs -n1 sudo -H pip install -U
}


# azure
#
export AZURE_CONFIG_DIR="$XDG_DATA_HOME"/azure
export AZURE_DEVOPS_CACHE_DIR="$XDG_CACHE_HOME"/azure-devops


# gem
#
export GEM_HOME="${XDG_DATA_HOME}"/gem
export GEM_SPEC_CACHE="${XDG_CACHE_HOME}"/gem


# ghcup
#
export GHCUP_USE_XDG_DIRS=true


# npm
#
export NPM_CONFIG_USERCONFIG="$XDG_CONFIG_HOME"/npm/npmrc


# environments and path
#
HOME_BIN="$HOME/.local/bin"
if [[ "$PATH" != *$HOME_BIN* ]]; then
    export PATH="${PATH:+${PATH}:}$HOME_BIN"
fi

LUA_LSP="$XDG_DATA_HOME/lua-language-server/bin"
if [[ -d "$LUA_LSP" ]] && [[ "$PATH" != *$LUA_LSP* ]]; then
    export PATH="${PATH:+${PATH}:}$LUA_LSP"
fi

FZF_ENV="$XDG_CONFIG_HOME/fzf/fzf.bash"
[[ -f "$FZF_ENV" ]] && source "$FZF_ENV"

GO_BIN=/usr/local/go/bin
if [[ -d "$GO_BIN" ]]; then
    if [[ "$PATH" != *$GO_BIN* ]]; then
        export PATH="${PATH:+${PATH}:}$GO_BIN"
    fi
    export GOPATH="$XDG_DATA_HOME"/go
    if [[ -d "$GOPATH"/bin ]] && [[ "$PATH" != "*$GOPATH/bin*" ]]; then
        export PATH="${PATH:+${PATH}:}$GOPATH/bin"
    fi
fi

CARGO_HOME="$XDG_DATA_HOME"/cargo
RUSTUP_HOME="$XDG_DATA_HOME"/rustup
if [[ -d "$CARGO_HOME/bin" ]] && [[ "$PATH" != *$CARGO_HOME/bin* ]]; then
    export CARGO_HOME
    export RUSTUP_HOME
    export PATH="$CARGO_HOME/bin:$PATH"
fi

CABAL_CONFIG="$XDG_CONFIG_HOME"/cabal/config
CABAL_DIR="$XDG_DATA_HOME"/cabal
if [[ -d "$CABAL_DIR" ]] && [[ "$PATH" != *$CABAL_DIR/bin* ]]; then
    export CABAL_CONFIG
    export CABAL_DIR
    export PATH="$CABAL_DIR/bin:$PATH"
fi

which nala &>/dev/null && alias apt='nala'


# projects
#
PROJECTS_DIR="$HOME/projects"
export PROJECTS_DIR

ASCII_ART="$PROJECTS_DIR/ascii_art"
[[ -d "$ASCII_ART" ]] && source "$ASCII_ART/ascii.bash"


# wsl settings
#
if [[ -n "$WSLENV" ]]; then
    winver="$(powershell.exe \[System.Environment\]::OSVersion.Version.Major)"

    if [[ "${winver%$'\r'}" == 10 ]]; then
        winpath="$(powershell.exe -command "echo \"\${env:USERPROFILE}\"")"
        xauthfile="$(wslpath "$winpath" | sed 's/[\r]//g')/.Xauthority"
        if [[ -f "$xauthfile" ]]; then
            touch "$XAUTHORITY"
            xauth -q merge "$xauthfile"
            DISPLAY="$(ip route show default | cut -d ' ' -f 3):0"
            LIBGL_ALWAYS_INDIRECT=0
            GALLIUM_DRIVER=llvmpipe
            export DISPLAY
            export LIBGL_ALWAYS_INDIRECT
            export GALLIUM_DRIVER
        fi
    fi

    print-path() {
        printf "%s\n" "${PATH//:/$'\n'}" | grep -v '^/mnt/c/'
    }
else
    print-path() {
        printf "%s\n" "${PATH//:/$'\n'}"
    }
fi


# git
#
alias gs='git status'
alias gf='git fetch'
alias gfa='git fetch --all'
alias gp='git pull'
alias gst='git stash'
alias ga='git add'
alias gaa='git add .'
alias gc='git commit'
alias gca='git commit --amend'
alias gb='git branch'
alias gd='git diff'
alias gdh='git diff HEAD'
alias gds='git diff --staged'
alias gdt='git difftool'
alias gdth='git difftool HEAD'
alias gdts='git difftool --staged'
alias gmt='git mergetool'
alias git-last-message='git show -s --format=%s'
alias git-reset-last='git reset HEAD~1'
alias rebase-origin='rebase-remote origin'
alias rebase-upstream='rebase-remote upstream'

get-branch-name() {
    local dir=$PWD
    if [[ $# != 0 ]]; then
        dir="$1"
    fi

    git -C "$dir" rev-parse --abbrev-ref HEAD
}

edit-past-commit() {
    if [[ $# == 0 ]]; then
        echo "error: missing commit-id"
        echo "usage: update-past-commit <commit-id>"
        return 1
    fi

    git rebase --interactive "$1"^
}

rebase-remote() {
    if [[ $# -eq 0 ]]; then
        echo 'error: need remote name'
        echo 'usage: rebase-remote <remote> [branch]'
    fi

    local current_branch
    current_branch=$(get-branch-name "$2")
    if [[ -z "$current_branch" ]]; then
        return 1
    fi

    local branch="master"
    if [[ $# -gt 1 ]]; then
        branch="$2"
    fi

    git fetch --all
    git rebase "$1/$branch" "$branch"

    if [[ "$current_branch" != "$branch" ]]; then
        git checkout "$current_branch"
    fi
}

add-exclude() {
    local repo_config="$PWD"
    if [[ $# -eq 2 ]]; then
        repo_config=$2
    elif [[ $# -ne 1 ]]; then
        echo "error: bad arguments: '$*'"
        echo 'usage: add_exclude <exclude-line> [repo-directory]'
        return 1
    fi

    repo_config+='/.git/info/exclude'
    if [[ -z "$repo_config" ]]; then
        echo "error: repo_config not found: '$repo_config'"
        return 1
    fi

    if ! grep -q "^${1}\$" "$repo_config"; then
        echo "adding '$1' to '$repo_config'"
        echo "$1" >> "$repo_config"
    else
        echo "'$1' already exists in '$repo_config'"
    fi
}

add-exclude-vscode() {
    local repo=$PWD
    if [[ $# -gt 1 ]]; then
        repo=$1
    fi
    add-exclude '.vscode/' "$repo"
}


# ips and ssh targets
#
alias pingpath='mtr'
alias myip='curl -s checkip.amazonaws.com'


# permissions
#
alias mx='chmod a+x'


# other
#
psgrep() {
    pgrep "$@" | xargs --no-run-if-empty ps -fp
}

pskill() {
    local pid
    pid=$(pgrep "$@" | xargs -r ps --no-headers -fp | awk '{ print $2 }')
    echo "killing $1 (process $pid)..."
    kill -9 "$pid"
}

extract() {
    if [ -f "$1" ]; then
        case $1 in
            *.tar.bz2) tar xvjf "$1" ;;
            *.tar.gz) tar xvzf "$1" ;;
            *.tar.xz) tar xvf "$1" ;;
            *.bz2) bunzip2 "$1" ;;
            *.rar) unrar x "$1" ;;
            *.gz) gunzip "$1" ;;
            *.tar) tar xvf "$1" ;;
            *.tbz2) tar xvjf "$1" ;;
            *.tgz) tar xvzf "$1" ;;
            *.zip) unzip "$1" ;;
            *.Z) uncompress "$1" ;;
            *.7z) 7z x "$1" ;;
            *) echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

