#!/bin/bash

#
# ~/.bash_profile
#

# --------------------------------------------------
# terminal prompt settings
# --------------------------------------------------

# XDG defaults
export XDG_DATA_HOME="${HOME}/.local/share"
export XDG_CONFIG_HOME="${HOME}/.config"
export XDG_STATE_HOME="${HOME}/.local/state"
export XDG_CACHE_HOME="${HOME}/.cache"
export XDG_RUNTIME_DIR="/run/user/${uid}"

# # bash colors
# export GREEN="\[\033[0;32m\]"
# export CYAN="\[\033[0;36m\]"
# export RED="\[\033[0;31m\]"
# export PURPLE="\[\033[0;35m\]"
# export BROWN="\[\033[0;33m\]"
# export LIGHT_GRAY="\[\033[0;37m\]"
# export LIGHT_BLUE="\[\033[1;34m\]"
# export LIGHT_GREEN="\[\033[1;32m\]"
# export LIGHT_CYAN="\[\033[1;36m\]"
# export LIGHT_RED="\[\033[1;31m\]"
# export LIGHT_PURPLE="\[\033[1;35m\]"
# export YELLOW="\[\033[1;33m\]"
# export WHITE="\[\033[1;37m\]"
# export RESTORE="\[\033[0m\]" #0m restores to the terminal's default color
#
# # apply bash prompt colors if available
# if [[ "$TERM" == +(xterm-color|*-256color) ]] ||
#     grep -q "^$TERM$" <<< "$(dircolors -p)"; then
#     if [[ "$(id -u)" -eq 0 ]]; then
#         PS1="$LIGHT_RED\u@\h$LIGHT_GRAY:$LIGHT_BLUE\w$LIGHT_GRAY# "
#     else
#         PS1="$LIGHT_GREEN\u@\h$LIGHT_GRAY:$LIGHT_BLUE\w$LIGHT_GRAY\$ "
#     fi
# else
#     PS1='\u@\h:\w\$ '
# fi
#
# PS2="> "
# PS3="> "
# PS4="+ "
#
# case "$TERM" in
#     xterm*|rxvt*|Eterm|aterm|kterm|gnome*)
#         PS1="\[\e]0;${PROMPT_COMMAND:+($PROMPT_COMMAND)}\u@\h:\w\a\]$PS1"
#         ;;
#     screen*)
#         PROMPT_COMMAND=${PROMPT_COMMAND:+$PROMPT_COMMAND; }'printf \
#             "\033_%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
#         ;;
#     *)
#         ;;
# esac

# shopt
shopt -s \
    autocd cdspell checkhash checkjobs checkwinsize cmdhist dirspell dotglob \
    expand_aliases extglob extquote globstar histappend interactive_comments \
    no_empty_cmd_completion progcomp promptvars sourcepath xpg_echo

# command-not-found
command_not_found_handle() {
    # check because c-n-f could've been removed in the meantime
    if [[ -x /usr/lib/command-not-found ]]; then
        /usr/lib/command-not-found -- "$1"
        return $?
    elif [[ -x /usr/share/command-not-found/command-not-found ]]; then
        /usr/share/command-not-found/command-not-found -- "$1"
        return $?
    else
        printf "%s: command not found\n" "$1" >&2
        return 127
    fi
}

# bash history
PROMPT_COMMAND='history -a'
HISTSIZE=10000
HISTFILESIZE=100000
export HISTCONTROL=ignoredups
export HISTIGNORE='history:pwd:ls:ll:la:l:'
export HISTTIMEFORMAT='%F %T '
export HISTFILE="${XDG_STATE_HOME}/bash/history"

# gpg tty
GPG_TTY=$(tty)
export GPG_TTY

# nvim
export EDITOR='nvim'

# less
#
export LESSHISTFILE="${XDG_STATE_HOME}/less/history"
LESS_TERMCAP_mb="$(printf '\E[01;31m')"
LESS_TERMCAP_md="$(printf '\E[01;38;5;74m')"
LESS_TERMCAP_me="$(printf '\E[0m')"
LESS_TERMCAP_se="$(printf '\E[0m')"
LESS_TERMCAP_so="$(printf '\E[38;5;246m')"
LESS_TERMCAP_ue="$(printf '\E[0m')"
LESS_TERMCAP_us="$(printf '\E[04;38;5;146m')"
export LESS_TERMCAP_mb
export LESS_TERMCAP_md
export LESS_TERMCAP_me
export LESS_TERMCAP_se
export LESS_TERMCAP_so
export LESS_TERMCAP_ue
export LESS_TERMCAP_us


# --------------------------------------------------
# extra XDG settings
# --------------------------------------------------

# azure
export AZURE_CONFIG_DIR="${XDG_CONFIG_HOME}/azure"
export AZURE_DEVOPS_CACHE_DIR="${XDG_CACHE_HOME}/azure-devops"

# gem
export GEM_SPEC_CACHE="${XDG_CACHE_HOME}/gem"

# npm
export NPM_CONFIG_USERCONFIG="${XDG_CONFIG_HOME}/npm/npmrc"

# nuget
export NUGET_PACKAGES="${XDG_CACHE_HOME}/nuget_packages"

# pass
export PASSWORD_STORE_DIR="${XDG_DATA_HOME}/pass"

# pylint
export PYLINTHOME="${XDG_CACHE_HOME}/pylint"


# --------------------------------------------------
# other
# --------------------------------------------------

# print path
print-path() {
    printf "%s\n" "${PATH//:/$'\n'}"
}

# find process
psgrep() {
    pgrep "$@" | xargs --no-run-if-empty ps -fp
}

# find and kill process
pskill() {
    local pid
    pid="$(pgrep "$@" | xargs -r ps --no-headers -fp | awk '{ print $2 }')"
    echo "killing $1 (process $pid)..."
    kill -9 "$pid"
}

# compressed file extraction
extract() {
    if [[ -f "$1" ]]; then
        case "$1" in
            *.tar.bz2) tar xvjf "$1" ;;
            *.tar.gz) tar xvzf "$1" ;;
            *.tar.xz) tar xvf "$1" ;;
            *.bz2) bunzip2 "$1" ;;
            *.rar) unrar x "$1" ;;
            *.gz) gunzip "$1" ;;
            *.tar) tar xvf "$1" ;;
            *.tbz2) tar xvjf "$1" ;;
            *.tgz) tar xvzf "$1" ;;
            *.zip) unzip "$1" ;;
            *.Z) uncompress "$1" ;;
            *.7z) 7z x "$1" ;;
            *) echo "unknown compressed file type '.${1#*.}'" ;;
        esac
    else
        echo "not a valid file: '$1'"
    fi
}

# --------------------------------------------------
# user paths
# --------------------------------------------------

append_path() {
    if [[ ":${PATH}:" != *":$1:"* ]]; then
        export PATH="${PATH:+${PATH}:}${1}"
    fi
}

prepend_path() {
    if [[ ":${PATH}:" != *":$1:"* ]]; then
        export PATH="${1}${PATH:+:${PATH}}"
    fi
}

# local bin
prepend_path "${HOME}/.local/bin"

# cabal
export CABAL_DIR="${XDG_DATA_HOME}/cabal"
prepend_path "${CABAL_DIR}/bin"

# cargo
export CARGO_HOME="${XDG_DATA_HOME}/cargo"
prepend_path "${CARGO_HOME}/bin"

# go
export GOPATH="${XDG_DATA_HOME}/go"
prepend_path "${GOPATH}/bin"

# homebrew
eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

# stack
export STACK_ROOT="${XDG_DATA_HOME}/stack"
prepend_path "${STACK_ROOT}/bin"

# rustup
export RUSTUP_HOME="${XDG_DATA_HOME}/rustup"

unset -f append_path prepend_path

# --------------------------------------------------
# git
# --------------------------------------------------

# print the branch name of the current directory or a given one
get-branch-name() {
    local dir=$PWD
    if [[ -n "$1" ]]; then
        dir="$1"
    fi

    git -C "$dir" rev-parse --abbrev-ref HEAD
}

# run an interactive rebase starting at a given commit inclusively
rebase-at-commit() {
    if [[ -z "$1" ]]; then
        echo "error: missing commit-id"
        echo "usage: rebase-at-commit <commit-id>"
        return 1
    fi

    git rebase --interactive "$1"^
}

# rebase a branch on a given remote without having to manually stash any changes
rebase-remote() {
    if [[ $# -eq 0 ]]; then
        echo 'error: need remote name'
        echo 'usage: rebase-remote <remote> [branch]'
    fi

    local current_branch
    current_branch=$(get-branch-name "$2")
    if [[ -z "$current_branch" ]]; then
        return 1
    fi

    local branch="master"
    if [[ $# -gt 1 ]]; then
        branch="$2"
    fi

    git fetch --all
    git rebase "$1/$branch" "$branch"

    if [[ "$current_branch" != "$branch" ]]; then
        git checkout "$current_branch"
    fi
}

# add a pattern to .git/info/exclude
add-exclude() {
    local repo_config="$PWD"
    if [[ $# -eq 2 ]]; then
        repo_config=$2
    elif [[ $# -ne 1 ]]; then
        echo "error: bad arguments: '$*'"
        echo 'usage: add_exclude <exclude-line> [repo-directory]'
        return 1
    fi

    repo_config+='/.git/info/exclude'
    if [[ -z "$repo_config" ]]; then
        echo "error: repo_config not found: '$repo_config'"
        return 1
    fi

    if ! grep -q "$(printf '^%q$' "$1")" "$repo_config"; then
        echo "adding '$1' to '$repo_config'"
        echo "$1" >> "$repo_config"
    else
        echo "'$1' already exists in '$repo_config'"
    fi
}

# add '.vscode*' to .git/info/exclude
add-exclude-vscode() {
    local repo=$PWD
    if [[ -n "$1" ]]; then
        repo=$1
    fi
    add-exclude ".vscode*" "$repo"
}

# diff compare against the same branch on a remote
diff-remote() {
    if [[ -z "$1" ]]; then
        echo "error: missing remote name"
        echo "usage: diff-remote <remote> [diff args]"
        return 1
    fi

    if [[ ! -d .git/ ]]; then
        echo "error: not a git directory"
        return 1
    fi

    if ! git remote | grep -q "$1"; then
        echo "error: unknown remote '$1'"
        return 1
    fi

    git diff "$1/$(get-branch-name)" "${@:2}"
}

# run difftool against the same branch on a remote
difftool-remote() {
    if [[ -z "$1" ]]; then
        echo "error: missing remote name"
        echo "usage: difftool-remote <remote> [difftool args]"
        return 1
    fi

    if [[ ! -d .git/ ]]; then
        echo "error: not a git directory"
        return 1
    fi

    if ! git remote | grep -q "$1"; then
        echo "error: unknown remote '$1'"
        return 1
    fi

    git difftool "$1/$(get-branch-name)" "${@:2}"
}


# --------------------------------------------------
# rc files
# --------------------------------------------------

# bash_login
[[ -f "${HOME}/.bash_login" ]] && source "${HOME}/.bash_login"

# bashrc
[[ -f "${HOME}/.bashrc" ]] && source "${HOME}/.bashrc"

